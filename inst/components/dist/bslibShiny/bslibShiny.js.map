{
  "version": 3,
  "sources": ["../../../../srcts/src/components/_utils.ts", "../../../../srcts/src/components/bslibShiny.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n};\nexport type { HtmlDep };\n", "import type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\nimport { InputBinding } from \"./_utils\";\n\ninterface ElementInputBinding {\n  element?: HTMLElement;\n  binding?: InputBindingType;\n}\n\nfunction getShinyInputBinding(id: string): ElementInputBinding {\n  const ret = {} as ElementInputBinding;\n\n  ret.element = document.getElementById(id) as HTMLElement;\n  if (!ret.element) {\n    console.warn(\"[bslib] No input element found\", { id });\n    return ret;\n  }\n\n  ret.binding = $(ret.element).data(\"shiny-input-binding\");\n\n  if (!(ret.binding instanceof InputBinding)) {\n    console.warn(\"[bslib] No input binding found\", { id });\n    return ret;\n  }\n\n  return ret;\n}\n\nShiny.addCustomMessageHandler(\"bslib.toggle-input-binary\", function (msg) {\n  // This handler was written for `toggle_switch()`, but could be used for any\n  // binary Shiny input, e.g. checkbox.\n\n  const { element, binding } = getShinyInputBinding(msg.id);\n  if (typeof element === \"undefined\" || typeof binding === \"undefined\") return;\n\n  let value = msg.value;\n  if (typeof value === \"undefined\") {\n    value = !binding.getValue(element);\n  }\n  binding.receiveMessage(element, { value });\n});\n\nShiny.addCustomMessageHandler(\n  \"bslib.disable-input\",\n  function ({ id, disable }: { id: string; disable: boolean | undefined }) {\n    // In the future we could use the binding (e.g. .getState() method) to\n    // determine or set the disabled state.\n\n    const element = document.getElementById(id);\n    if (!(element instanceof HTMLElement)) return;\n\n    if (typeof disable === \"undefined\") {\n      disable = !(\n        element.hasAttribute(\"disabled\") ||\n        element.classList.contains(\"disabled\")\n      );\n    }\n\n    if (disable) {\n      element.setAttribute(\"disabled\", \"\");\n      element.classList.add(\"disabled\");\n    } else {\n      element.removeAttribute(\"disabled\");\n      element.classList.remove(\"disabled\");\n    }\n  }\n);\n"],
  "mappings": ";;;;AAQA,MAAM,eACJ,OAAO,QAAQ,MAAM,eAAe,MAAM;AAAA,EAAC;;;ACD7C,WAAS,qBAAqB,IAAiC;AAC7D,UAAM,MAAM,CAAC;AAEb,QAAI,UAAU,SAAS,eAAe,EAAE;AACxC,QAAI,CAAC,IAAI,SAAS;AAChB,cAAQ,KAAK,kCAAkC,EAAE,GAAG,CAAC;AACrD,aAAO;AAAA,IACT;AAEA,QAAI,UAAU,EAAE,IAAI,OAAO,EAAE,KAAK,qBAAqB;AAEvD,QAAI,EAAE,IAAI,mBAAmB,eAAe;AAC1C,cAAQ,KAAK,kCAAkC,EAAE,GAAG,CAAC;AACrD,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAEA,QAAM,wBAAwB,6BAA6B,SAAU,KAAK;AAIxE,UAAM,EAAE,SAAS,QAAQ,IAAI,qBAAqB,IAAI,EAAE;AACxD,QAAI,OAAO,YAAY,eAAe,OAAO,YAAY;AAAa;AAEtE,QAAI,QAAQ,IAAI;AAChB,QAAI,OAAO,UAAU,aAAa;AAChC,cAAQ,CAAC,QAAQ,SAAS,OAAO;AAAA,IACnC;AACA,YAAQ,eAAe,SAAS,EAAE,MAAM,CAAC;AAAA,EAC3C,CAAC;AAED,QAAM;AAAA,IACJ;AAAA,IACA,SAAU,EAAE,IAAI,QAAQ,GAAiD;AAIvE,YAAM,UAAU,SAAS,eAAe,EAAE;AAC1C,UAAI,EAAE,mBAAmB;AAAc;AAEvC,UAAI,OAAO,YAAY,aAAa;AAClC,kBAAU,EACR,QAAQ,aAAa,UAAU,KAC/B,QAAQ,UAAU,SAAS,UAAU;AAAA,MAEzC;AAEA,UAAI,SAAS;AACX,gBAAQ,aAAa,YAAY,EAAE;AACnC,gBAAQ,UAAU,IAAI,UAAU;AAAA,MAClC,OAAO;AACL,gBAAQ,gBAAgB,UAAU;AAClC,gBAAQ,UAAU,OAAO,UAAU;AAAA,MACrC;AAAA,IACF;AAAA,EACF;",
  "names": []
}
