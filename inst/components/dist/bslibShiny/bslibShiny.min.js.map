{
  "version": 3,
  "sources": ["../../../../srcts/src/components/_utils.ts", "../../../../srcts/src/components/bslibShiny.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n};\nexport type { HtmlDep };\n", "import type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\nimport { InputBinding } from \"./_utils\";\n\ninterface ElementInputBinding {\n  element?: HTMLElement;\n  binding?: InputBindingType;\n}\n\nfunction getShinyInputBinding(id: string): ElementInputBinding {\n  const ret = {} as ElementInputBinding;\n\n  ret.element = document.getElementById(id) as HTMLElement;\n  if (!ret.element) {\n    console.warn(\"[bslib] No input element found\", { id });\n    return ret;\n  }\n\n  ret.binding = $(ret.element).data(\"shiny-input-binding\");\n\n  if (!(ret.binding instanceof InputBinding)) {\n    console.warn(\"[bslib] No input binding found\", { id });\n    return ret;\n  }\n\n  return ret;\n}\n\nShiny.addCustomMessageHandler(\"bslib.toggle-input-binary\", function (msg) {\n  // This handler was written for `toggle_switch()`, but could be used for any\n  // binary Shiny input, e.g. checkbox.\n\n  const { element, binding } = getShinyInputBinding(msg.id);\n  if (typeof element === \"undefined\" || typeof binding === \"undefined\") return;\n\n  let value = msg.value;\n  if (typeof value === \"undefined\") {\n    value = !binding.getValue(element);\n  }\n  binding.receiveMessage(element, { value });\n});\n\nShiny.addCustomMessageHandler(\n  \"bslib.disable-input\",\n  function ({ id, disable }: { id: string; disable: boolean | undefined }) {\n    // In the future we could use the binding (e.g. .getState() method) to\n    // determine or set the disabled state.\n\n    const element = document.getElementById(id);\n    if (!(element instanceof HTMLElement)) return;\n\n    if (typeof disable === \"undefined\") {\n      disable = !(\n        element.hasAttribute(\"disabled\") ||\n        element.classList.contains(\"disabled\")\n      );\n    }\n\n    if (disable) {\n      element.setAttribute(\"disabled\", \"\");\n      element.classList.add(\"disabled\");\n    } else {\n      element.removeAttribute(\"disabled\");\n      element.classList.remove(\"disabled\");\n    }\n  }\n);\n"],
  "mappings": ";mBAQA,IAAMA,EACJ,OAAO,MAAQ,MAAM,aAAe,KAAM,CAAC,ECD7C,SAASC,EAAqBC,EAAiC,CAC7D,IAAMC,EAAM,CAAC,EAGb,OADAA,EAAI,QAAU,SAAS,eAAeD,CAAE,EACnCC,EAAI,SAKTA,EAAI,QAAU,EAAEA,EAAI,OAAO,EAAE,KAAK,qBAAqB,EAEjDA,EAAI,mBAAmBC,GAC3B,QAAQ,KAAK,iCAAkC,CAAE,GAAAF,CAAG,CAAC,EAC9CC,IARP,QAAQ,KAAK,iCAAkC,CAAE,GAAAD,CAAG,CAAC,EAC9CC,EAWX,CAEA,MAAM,wBAAwB,4BAA6B,SAAUE,EAAK,CAIxE,GAAM,CAAE,QAAAC,EAAS,QAAAC,CAAQ,EAAIN,EAAqBI,EAAI,EAAE,EACxD,GAAI,OAAOC,GAAY,aAAe,OAAOC,GAAY,YAAa,OAEtE,IAAIC,EAAQH,EAAI,MACZ,OAAOG,GAAU,cACnBA,EAAQ,CAACD,EAAQ,SAASD,CAAO,GAEnCC,EAAQ,eAAeD,EAAS,CAAE,MAAAE,CAAM,CAAC,CAC3C,CAAC,EAED,MAAM,wBACJ,sBACA,SAAU,CAAE,GAAAN,EAAI,QAAAO,CAAQ,EAAiD,CAIvE,IAAMH,EAAU,SAAS,eAAeJ,CAAE,EACpCI,aAAmB,cAErB,OAAOG,GAAY,cACrBA,EAAU,EACRH,EAAQ,aAAa,UAAU,GAC/BA,EAAQ,UAAU,SAAS,UAAU,IAIrCG,GACFH,EAAQ,aAAa,WAAY,EAAE,EACnCA,EAAQ,UAAU,IAAI,UAAU,IAEhCA,EAAQ,gBAAgB,UAAU,EAClCA,EAAQ,UAAU,OAAO,UAAU,GAEvC,CACF",
  "names": ["InputBinding", "getShinyInputBinding", "id", "ret", "InputBinding", "msg", "element", "binding", "value", "disable"]
}
